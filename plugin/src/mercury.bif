module Mercury;

%%{
#include <cstddef>
#include <span>
#include <set>
#include <format>

// Algorithm from RFC 9000 Appendix A.1
std::optional<std::pair<uint64_t, size_t>> ReadVarint(std::span<const std::byte> data, bool keep_prefix = false) {
	if ( data.empty() )
		return std::nullopt;

	const std::byte first_byte = data[0];

	// first two bits encode length
	const uint8_t prefix = std::to_integer<uint8_t>(first_byte) >> 6;
	const size_t length = 1 << prefix;

	if ( data.size() < length )
		return std::nullopt;

	uint64_t value;
	if ( keep_prefix )
		// Don't remove the prefix from the first byte, as the reference implementation doesn't do so.
		value = std::to_integer<uint8_t>(first_byte);
	else
		value = std::to_integer<uint8_t>(first_byte) & 0x3F;

	for ( size_t i = 1; i < length; ++i )
		value = ( value << 8 ) | std::to_integer<uint8_t>(data[i]);

	return std::make_pair(value, length);
}

%%}

## Decode quic_transport_parameters and return a list of them as a string vector
## Grease values are converted to 1b
## Vector is sorted
function quic_transport_parameter%(ext: string%): string_vec
	%{
	auto result = zeek::make_intrusive<zeek::VectorVal>(zeek::id::string_vec);

	std::multiset<uint64_t> parameter_ids;
	const u_char* ext_val = ext->Bytes();
	unsigned int length = ext->Len();

	std::span<const u_char> source_span(ext_val, length);
	std::span<const std::byte> buffer = std::as_bytes(source_span);

	while ( ! buffer.empty() ) {
		// RFC 9000 Section 18:
		// Transport Parameter {
		//  Transport Parameter ID (i),
		//  Transport Parameter Length (i),
		//  Transport Parameter Value (..),
		// }

		// FIXME: this is a workaround for the fact that the mercury implementation uses
		// a combination of numbers with and without the prefix for the fingerprint
		auto tp_id = ReadVarint(buffer, false);
		auto tp_id_with_prefix = ReadVarint(buffer, true);

		if ( ! tp_id || ! tp_id_with_prefix )
			return result;

		// degrease
		if ( tp_id->first % 31 == 27 ) // for degreasing - use the actual value
			parameter_ids.insert(27);
		else
			parameter_ids.insert(tp_id_with_prefix->first); // but for adding, use the one with prefix

		buffer = buffer.subspan(tp_id->second);

		auto tp_length = ReadVarint(buffer);

		if ( ! length )
			return result;

		// have to skip length of lenth field, plus length of value
		if ( buffer.size() < tp_length->first + tp_length->second )
			return result;

		buffer = buffer.subspan(tp_length->first + tp_length->second);
	}

	for ( auto const &id : parameter_ids )
		{
		// Probably will have to change this for older distributions.
		result->Append(zeek::make_intrusive<zeek::StringVal>(std::format("({:02x})", id)));
		}

	return result;
	%}
